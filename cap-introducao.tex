%% ------------------------------------------------------------------------- %%
\chapter{Introdução}
\label{cap:introducao}


Neste trabalho será abordado um importante tópico da Teoria de Grafos: o ancestral comum mais próximo - ou simplesmente LCA (derivado do inglês \emph{Lowest Common 
Ancestor}).

A motivação para o estudo este assunto vem majoritariamente da Maratona de Programação. Nestas competições os participantes  são expostos a desafios lógicos que requerem a escrita de códigos que, para uma entrada de um problema, são capazes de retornar sua resposta esperada. Um ótimo material (porém em Inglês) sobre \LCA\ utilizado por muitos competidores para aprender mais sobre este problema é o tutorial do website TopCoder \cite{top-coder}.

Entender o problema de encontrar o LCA entre dois vértices de uma árvore não é uma 
tarefa complicada. Ademais, escrever um algoritmo simples para tal também não possui 
um grau de complexidade elevado. Entretanto, nessas competições sempre procuramos 
resolver os problemas de forma eficiente, visto que o tamanho da entrada pode ser 
grande o suficiente para exigir um algoritmo rápido (e, geralmente, mais complexo) 
que termine sua execução dentro do tempo limite proposto.

Diversos algoritmos são conhecidos para encontrar o LCA - uns mais eficientes do 
que outros. Ao longo deste trabalho me aprofundarei em algumas soluções, partindo 
de algoritmos mais simples porém ineficientes até uma solução eficiente e mais complexa.

O trabalho será abordado com viés didático, visando o aprendizado do leitor. 
Para isso, ao apresentar algoritmos sempre procuro fornecer códigos e, no final da
monografia, resolver alguns problemas interessantes de juízes \emph{online} que 
exploram o tema estudado.


\section{Organização do texto}

O capítulo 2 aborda conceitos importantes para o entendimento do trabalho.

\vspace{0.2cm}

O capítulo 3 descreve o problema do \LCA\ e apresenta um algoritmo simples (porém ineficiente) para resolvê-lo.

\vspace{0.2cm}

O capítulo 4 apresenta uma otimização do algoritmo inicial mostrado.

\vspace{0.2cm}

O capítulo 5 aborda o problema usando a famosa técnica chamada de Programação Dinâmica. A complexidade obtida neste algoritmo é a desejável para este trabalho.

\vspace{0.2cm}

O capítulo 6 mostra como o problema pode ser resolvido quando reduzido ao problema de achar o elemento mínimo em um intervalo. Além da complexidade ótima obtida, esta solução também possibilita atualizar os valores dos vértices da árvore.

\vspace{0.2cm}

No capítulo 7 alguns problemas de juízes online selecionados são resolvidos, para demonstrar a aplicação prática dos algoritmos estudados neste trabalho.

\vspace{0.2cm}

No capítulo 8 é feita a conclusão, apresentando os resultados obtidos com o trabalho.


\section{Complexidade dos algoritmos estudados}

Durante o trabalho serão estudados quatro algoritmos. A complexidade de tempo de cada um pode ser visualizada na tabela abaixo:

\vspace{0.5cm}

\begin{table}[htb]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Algoritmo}      & \textbf{Complexidade} \\ \hline
Algoritmo simples       & $O(n)$                  \\ \hline
Descomposição em Baldes & $O(\sqrt{n})$            \\ \hline
Programação dinâmica    & $O(log\ n)$              \\ \hline
Passeio de Euler        & $O(log\ n)$              \\ \hline
\end{tabular}
\end{table}